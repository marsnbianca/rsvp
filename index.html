/** RSVP Web App v1production (router: find/get/submit)
 * Sheet headers expected:
 * invite_id, invite_name, relationship, max_seats, status, attending_count,
 * attendee_fullname, phone, transportation, notes, updated_at
 */

const SPREADSHEET_ID = "1D8DrNXPUFTzTr0WdidqQZOYo2IXHzseZ-4xpR5CtEic";
const SHEET_GUESTLIST = "GuestList";

function doPost(e) {
  try {
    const body = e && e.postData && e.postData.contents ? e.postData.contents : "{}";
    const payload = JSON.parse(body);

    const action = String(payload.action || "").toLowerCase().trim();
    if (action === "find") return json_(find_(payload));
    if (action === "get") return json_(get_(payload));
    if (action === "submit") return json_(submit_(payload));

    return json_({ ok: false, error: "Unknown action." });
  } catch (err) {
    return json_({ ok: false, error: String(err && err.message ? err.message : err) });
  }
}

function json_(obj) {
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * FIND
 * Expects: { query }
 * Returns: matches: [{ invite_id, display_name, party_size }]
 */
function find_(payload) {
  const query = normalize_(payload.query || "");
  if (!query) return { ok: true, matches: [] };

  const sh = getSheet_();
  const values = sh.getDataRange().getValues();
  if (values.length < 2) return { ok: true, matches: [] };

  const header = values[0].map(h => String(h || "").trim());
  const idx = indexMap_(header);

  const cInviteId = idx.invite_id;
  const cInviteName = idx.invite_name;
  const cMaxSeats = idx.max_seats;

  if (cInviteId < 0 || cInviteName < 0) {
    return { ok: false, error: "Missing required headers: invite_id, invite_name." };
  }

  // De-dupe by invite_id so we don't show multiple attendee rows as multiple matches
  const seen = new Set();
  const out = [];

  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    const inviteId = String(row[cInviteId] || "").trim();
    const inviteName = String(row[cInviteName] || "").trim();
    if (!inviteId || !inviteName) continue;

    if (seen.has(inviteId)) continue;
    if (!nameMatches_(inviteName, query)) continue;

    seen.add(inviteId);
    out.push({
      invite_id: inviteId,
      display_name: inviteName,
      party_size: cMaxSeats >= 0 ? Number(row[cMaxSeats] || 0) : 0
    });
  }

  return { ok: true, matches: out.slice(0, 25) };
}

/**
 * GET
 * Expects: { invite_id }
 * Returns: { invite: { invite_id, invite_name, party:[{row_index, attendee_id, full_name, status, transportation, phone, notes, updated_at}] } }
 */
function get_(payload) {
  const inviteId = String(payload.invite_id || "").trim();
  if (!inviteId) return { ok: false, error: "Missing invite_id." };

  const sh = getSheet_();
  const values = sh.getDataRange().getValues();
  if (values.length < 2) return { ok: false, error: "GuestList is empty." };

  const header = values[0].map(h => String(h || "").trim());
  const idx = indexMap_(header);

  const cInviteId = idx.invite_id;
  const cInviteName = idx.invite_name;

  const cStatus = idx.status;
  const cAttendeeFullname = idx.attendee_fullname;
  const cPhone = idx.phone;
  const cTransportation = idx.transportation;
  const cNotes = idx.notes;
  const cUpdatedAt = idx.updated_at;

  if (cInviteId < 0 || cInviteName < 0 || cAttendeeFullname < 0) {
    return { ok: false, error: "Missing required headers: invite_id, invite_name, attendee_fullname." };
  }

  let inviteName = "";
  const party = [];

  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    if (String(row[cInviteId] || "").trim() !== inviteId) continue;

    if (!inviteName) inviteName = String(row[cInviteName] || "").trim();

    party.push({
      row_index: r + 1, // sheet row number
      attendee_id: String(party.length + 1), // derived since you don't have an attendee_id column
      full_name: String(row[cAttendeeFullname] || "").trim(),
      status: cStatus >= 0 ? String(row[cStatus] || "").trim() : "",
      transportation: cTransportation >= 0 ? String(row[cTransportation] || "").trim() : "",
      phone: cPhone >= 0 ? String(row[cPhone] || "").trim() : "",
      notes: cNotes >= 0 ? String(row[cNotes] || "").trim() : "",
      updated_at: cUpdatedAt >= 0 ? String(row[cUpdatedAt] || "").trim() : ""
    });
  }

  if (!inviteName) return { ok: false, error: "Invite not found." };

  return {
    ok: true,
    invite: {
      invite_id: inviteId,
      invite_name: inviteName,
      party
    }
  };
}

/**
 * SUBMIT
 * Expects:
 * {
 *   invite_id,
 *   invite_name,
 *   responses: {
 *     attending: "Yes"|"No",          -> written to status
 *     transportation: "Yes"|"No",
 *     phone: "...",
 *     party: [{ row_index, full_name/fullName, ... }]
 *   }
 * }
 */
function submit_(payload) {
  const inviteId = String(payload.invite_id || "").trim();
  if (!inviteId) return { ok: false, error: "Missing invite_id." };

  const responses = payload.responses || {};
  const party = Array.isArray(responses.party) ? responses.party : [];

  const sh = getSheet_();
  const values = sh.getDataRange().getValues();
  if (values.length < 2) return { ok: false, error: "GuestList is empty." };

  const header = values[0].map(h => String(h || "").trim());
  const idx = indexMap_(header);

  const cInviteId = idx.invite_id;
  const cInviteName = idx.invite_name;

  const cStatus = idx.status; // "Are you coming?"
  const cAttendingCount = idx.attending_count;
  const cAttendeeFullname = idx.attendee_fullname;
  const cPhone = idx.phone;
  const cTransportation = idx.transportation;
  const cNotes = idx.notes;
  const cUpdatedAt = idx.updated_at;

  if (cInviteId < 0 || cAttendeeFullname < 0) {
    return { ok: false, error: "Missing required headers: invite_id, attendee_fullname." };
  }

  // All sheet rows that belong to this invite
  const rowsForInvite = [];
  for (let r = 1; r < values.length; r++) {
    if (String(values[r][cInviteId] || "").trim() === inviteId) {
      rowsForInvite.push(r + 1); // sheet row number
    }
  }
  if (!rowsForInvite.length) return { ok: false, error: "Invite not found." };

  const updatedAt = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");

  const attendingValue = responses.attending != null ? String(responses.attending).trim() : "";
  const transportationValue = responses.transportation != null ? String(responses.transportation).trim() : "";
  const phoneValue = responses.phone != null ? String(responses.phone).trim() : "";

  // IMPORTANT: always handle attendee 1 (index 0) too
  // Write attendee_fullname for each party row using its row_index.
  // If row_index is missing, map sequentially onto rowsForInvite.
  if (party.length) {
    for (let i = 0; i < party.length; i++) {
      const p = party[i] || {};

      const fullName = (p.full_name != null ? p.full_name : p.fullName);
      const nameToWrite = fullName != null ? String(fullName).trim() : "";

      let targetRow = p.row_index ? Number(p.row_index) : null;
      if (!targetRow || isNaN(targetRow)) {
        targetRow = rowsForInvite[i] || rowsForInvite[rowsForInvite.length - 1];
      }

      // attendee_fullname
      sh.getRange(targetRow, cAttendeeFullname + 1).setValue(nameToWrite);

      // keep these consistent across all attendee rows
      if (cStatus >= 0 && attendingValue) sh.getRange(targetRow, cStatus + 1).setValue(attendingValue);
      if (cTransportation >= 0 && transportationValue) sh.getRange(targetRow, cTransportation + 1).setValue(transportationValue);
      if (cPhone >= 0 && phoneValue) sh.getRange(targetRow, cPhone + 1).setValue(phoneValue);
      if (cUpdatedAt >= 0) sh.getRange(targetRow, cUpdatedAt + 1).setValue(updatedAt);
    }
  } else {
    // No party array sent: still record the overall selections on all rows
    for (let j = 0; j < rowsForInvite.length; j++) {
      const rowNum = rowsForInvite[j];
      if (cStatus >= 0 && attendingValue) sh.getRange(rowNum, cStatus + 1).setValue(attendingValue);
      if (cTransportation >= 0 && transportationValue) sh.getRange(rowNum, cTransportation + 1).setValue(transportationValue);
      if (cPhone >= 0 && phoneValue) sh.getRange(rowNum, cPhone + 1).setValue(phoneValue);
      if (cUpdatedAt >= 0) sh.getRange(rowNum, cUpdatedAt + 1).setValue(updatedAt);
    }
  }

  // attending_count:
  // If "No" => 0
  // If "Yes" => count non-empty attendee_fullname from submitted party (fallback to current sheet if party missing)
  let count = 0;
  if (attendingValue.toLowerCase() === "yes") {
    if (party.length) {
      count = party.filter(p => {
        const fn = (p && (p.full_name != null ? p.full_name : p.fullName)) ? String(p.full_name != null ? p.full_name : p.fullName).trim() : "";
        return !!fn;
      }).length;
    } else {
      // fallback: count existing names on sheet for this invite
      for (let k = 0; k < rowsForInvite.length; k++) {
        const rowNum = rowsForInvite[k];
        const val = String(sh.getRange(rowNum, cAttendeeFullname + 1).getValue() || "").trim();
        if (val) count++;
      }
    }
  } else if (attendingValue.toLowerCase() === "no") {
    count = 0;
  }

  // write attending_count + invite_name on FIRST row only
  const firstRow = rowsForInvite[0];
  if (cAttendingCount >= 0) sh.getRange(firstRow, cAttendingCount + 1).setValue(count);

  const incomingInviteName = String(payload.invite_name || "").trim();
  if (incomingInviteName && cInviteName >= 0) {
    sh.getRange(firstRow, cInviteName + 1).setValue(incomingInviteName);
  }

  // updated_at on first row too (in case party was shorter than existing rows)
  if (cUpdatedAt >= 0) sh.getRange(firstRow, cUpdatedAt + 1).setValue(updatedAt);

  return { ok: true, updated_at: updatedAt, attending_count: count };
}

/** Helpers **/

function getSheet_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(SHEET_GUESTLIST);
  if (!sh) throw new Error("GuestList sheet not found.");
  return sh;
}

function indexMap_(headerRow) {
  const map = {};
  for (let i = 0; i < headerRow.length; i++) {
    const key = normalizeHeader_(headerRow[i]);
    if (!key) continue;
    map[key] = i;
  }
  return map;
}

function normalizeHeader_(h) {
  return String(h || "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, "_");
}

function normalize_(s) {
  return String(s || "")
    .toLowerCase()
    .trim()
    .replace(/\s+/g, " ")
    .replace(/[â€™']/g, "'")
    .replace(/[^a-z0-9\s'-]/g, "");
}

function nameMatches_(candidateName, queryNormalized) {
  const c = normalize_(candidateName);
  if (!c || !queryNormalized) return false;

  if (c === queryNormalized) return true;
  if (c.indexOf(queryNormalized) >= 0) return true;

  const qTokens = queryNormalized.split(" ").filter(Boolean);
  let hits = 0;
  for (const t of qTokens) {
    if (t.length < 2) continue;
    if (c.indexOf(t) >= 0) hits++;
  }
  return hits >= Math.max(1, Math.ceil(qTokens.length * 0.6));
}
